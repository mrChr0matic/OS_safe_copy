alias functionNum R1;
alias currentPID R2;

// Acquire Disk
if(functionNum == 3) then
	while([DISK_STATUS_TABLE + 0] == 1) do
		[PROCESS_TABLE + currentPID*16 + 4] = WAIT_DISK;
		multipush(R1, R2);
		call MOD_5;
		multipop(R1, R2);
	endwhile;
	[DISK_STATUS_TABLE + 0] = 1;
	[DISK_STATUS_TABLE + 4] = currentPID;
endif;

// acquire inode fno:4
if (functionNum == ACQUIRE_INODE) then
	alias inodeIdx R2;
	alias PID R3;
	print inodeIdx;

	//busy wait
	while( ([FILE_STATUS_TABLE + inodeIdx*4 + 0] != -1) ) do
		[PROCESS_TABLE + PID*16 + 4] = WAIT_FILE;
		[PROCESS_TABLE + PID*16 + 5] = inodeIdx;
		multipush(R0, R1, R2, R3);
		call SCHEDULER;
		multipop(R0, R1, R2, R3);
	endwhile;

	//if file has already been deleted
	if([INODE_TABLE + inodeIdx*16 + 1] == -1 ) then
		R0 = -1;
		return;
	endif;

	//lock the inode entry
	[FILE_STATUS_TABLE + inodeIdx*4 + 0] = PID;
	R0 = 0;
	return;
endif;

// release inode fno:5
if (functionNum == RELEASE_INODE) then
	alias inodeIdx R2;
	alias PID R3;

	if([FILE_STATUS_TABLE + inodeIdx*4 + 0] != PID ) then
		// PID is not matching the locking pid
		R0 = -1;
		return;
	endif;

	//unlock the file
	[FILE_STATUS_TABLE + inodeIdx*4 + 0] = -1;

	//loop through the process and wake them up
	alias i R4;
	i = 0;
	while( i < MAX_PROC_NUM ) do
		if( ([PROCESS_TABLE + i*16 + 4] == WAIT_FILE) && ([PROCESS_TABLE + i*16 + 5] == inodeIdx) ) then
			[PROCESS_TABLE + i*16 + 4] = READY;
		endif;
		i = i + 1;
	endwhile;
	
	R0 = 0;
	return;
endif;


//AcquireSemaphore
if(functionNum == 6) then
  alias i R3;
  i = 0;
  while([SEMAPHORE_TABLE + 4*i + 1] != 0) do
    i = i + 1;
  endwhile;
  if(i==32) then
    R0 = -1;
    return;
  endif;
  [SEMAPHORE_TABLE + 4*i + 1] = 1;
  [SEMAPHORE_TABLE + 4*i] = -1;
  R0 = i;
  return;
endif;

//Release Semaphore
if(functionNum == 7) then
  if([SEMAPHORE_TABLE + 4*R2] == R3) then
    [SEMAPHORE_TABLE + 4*R2] = -1;
    alias i R4;
    i=1;
    while(i<16) do
      alias procTab R5;
      procTab = PROCESS_TABLE + 16*i;
      if([procTab + 4] == WAIT_SEMAPHORE && [procTab + 5] == R2) then
        [procTab + 4] = READY;
        [procTab + 5] = -1;
      endif;
      i = i + 1;
    endwhile;
  endif;
  [SEMAPHORE_TABLE + 4*R2 + 1] = [SEMAPHORE_TABLE + 4*R2 + 1] -1;
  R0 = 0;
  return;
endif;




// Acquire Terminal :
if(functionNum == 8) then
	while([TERMINAL_STATUS_TABLE+0] == 1) do
		[PROCESS_TABLE + currentPID*16 + 4] = WAIT_TERMINAL;
		multipush(R1, R2);
		call MOD_5;
		multipop(R1, R2);
	endwhile;
	
	[TERMINAL_STATUS_TABLE + 0] = 1;
	[TERMINAL_STATUS_TABLE + 1] = currentPID;
	breakpoint;
	return;
endif;

// Release Terminal
if(functionNum == 9) then
	if(currentPID != [TERMINAL_STATUS_TABLE + 1]) then
		alias retVal R0;
		retVal = -1;
		return;

	else
		[TERMINAL_STATUS_TABLE + 0] = 0;
		alias i R3;
		i = 0;
		while(i<16) do
			alias pid R4;
			pid = [PROCESS_TABLE + 16*i + 1];
			if( pid>0 && pid<16) then
				if([PROCESS_TABLE + 16*i + 4] == WAIT_TERMINAL) then
					[PROCESS_TABLE + 16*i + 4] = READY;
				endif;
			endif;
			i = i + 1;
		endwhile;
		alias retVal R0;
		retVal = 0;
		breakpoint;
		return;
	endif;
else
alias retVal R0;
retVal = -1;
return;
endif;